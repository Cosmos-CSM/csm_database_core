using System.Reflection;
using System.Text.Json;

using CSM_Database_Core.Core.Attributes;
using CSM_Database_Core.Core.Models;
using CSM_Database_Core.Entities.Abstractions.Interfaces;

using CSM_Foundation_Core;
using CSM_Foundation_Core.Core.Exceptions;
using CSM_Foundation_Core.Core.Utils;

using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;

namespace CSM_Database_Core.Core.Utilitites;

public class DatabaseUtils {
    const string DirectoryName = ".Connection";
    const string QualityPrefix = "quality";
    const string DevelopmentPrefix = "development";
    const string ProductionPrefix = "production";


    /// <summary>
    ///     Connection file name template for Quality environment variable.
    /// </summary>
    const string Q_CONNTION_TMPLATE = "Q_{0}.Connection";

    /// <summary>
    ///     Fetches and loads through IO functionallities for private file based secret
    ///     connection properties for DataDatabasess connections handlers. 
    ///     Then build it and validate it to generate a Model.
    ///     
    ///     RECOMMENDED: Check the parameter documentation to ensure the correct use.
    /// </summary>
    /// <param name="cp"> 
    ///     Automatically gets the path of the method caller through execution-time assemblies access
    ///     attribute decorator, this is correctly calculated when the method is called
    ///     directly in the DataDatabases context class that is generated by the EF CLI tools when 
    ///     migrated a database configuration, otherwise can struggle with the correct project 
    ///     file leveling generation. 
    ///     In that kind of cases this parameter can be overwritten by the caller to inject
    ///     the correct dataDatabases project root path.
    /// </param>
    /// <returns>
    ///     <see cref="ConnectionOptions"/>: The dataDatabases connection properties gathered and retrieved from the found private properties file.
    /// </returns>
    /// <exception cref="Exception">
    ///     When something gone wrong during the IO connection properties gather operation.
    /// </exception>
    public static ConnectionOptions Retrieve(string DatabaseSign) {
        string wd = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)!;

        string prefix = SystemUtils.GetEnv() switch {
            SystemEnvs.DEV => Constants.Environments.DEV,
            SystemEnvs.PROD => Constants.Environments.PROD,
            SystemEnvs.QA => Constants.Environments.QA,
            SystemEnvs.LAB => Constants.Environments.LAB,
            _ => DevelopmentPrefix,
        };

        string fn = $"{prefix}.connection.json";

        if (wd is null) {
            throw new ArgumentNullException(wd);
        }

        string tp = $"{wd}\\{DatabaseSign.ToUpper()}{DirectoryName}";
        string? cpd = Directory.GetDirectories(wd)
            .Where(i => i == tp)
            .FirstOrDefault()
            ?? throw new DirectoryNotFoundException($"{tp} not found in the system");

        string tfn = $"{tp}\\{fn}";

        string[] cfs = Directory.GetFiles(cpd);
        string cpfi = cfs
            .Where(i => i == tfn)
            .FirstOrDefault()
            ?? throw new FileNotFoundException($"{tfn} not found in the system");

        using FileStream pfs = new(cpfi, FileMode.Open, FileAccess.Read, FileShare.Read);
        ConnectionOptions? m = JsonSerializer.Deserialize<ConnectionOptions>(pfs);
        pfs.Dispose();

        return m is null ? throw new Exception() : m;
    }

    /// <summary>
    ///     Sanitizes the entity relations to ensure that the relations are correctly tracked from the database and avoid the creation of relation entities wrongly given through the main entity.
    /// </summary>
    /// <typeparam name="TEntity">
    ///     Type of the Main Entity to be sanitized.
    /// </typeparam>
    /// <param name="database">
    ///     Database context handler for Entity to be sanitized.
    /// </param>
    /// <param name="entity">
    ///     Entity instance to be sanitized
    /// </param>
    /// <returns></returns>
    /// <exception cref="InvalidOperationException">
    ///     Thrown when the dbSet couldn't be found for the relation entity.
    ///     Thrown when a relation Entity is being tried to be created automatically.
    ///     Thrown when the relation isn´t a IEntity implementation neither a Collection of IEntity.
    /// </exception>
    /// <exception cref="Exception">
    ///     Thrown when the relation entity couldn't be found in the database.
    /// </exception>
    public static TEntity SanitizeEntity<TEntity>(DbContext database, TEntity entity) {


        IQueryable<IEntity> GetDbSet(Type entityType) {
            object objectDbSet = typeof(DbContext)
                .GetMethods()
                .Where(
                    m => m.Name == nameof(DbContext.Set) && m.IsGenericMethod && m.GetGenericArguments().Length == 1
                )
                .FirstOrDefault()?
                .MakeGenericMethod(entityType)
                .Invoke(database, null)
                ?? throw new($"DbContext({database.GetType().Name}) doesn´t have the neccesary DbSet({entityType.Name}) method", null);

            return (IQueryable<IEntity>)objectDbSet;
        }

        if (entity == null) {
            return entity;
        }

        IEnumerable<PropertyInfo> relationProperties = entity
            .GetType()
            .GetProperties()
            .Where(
                (pi) => pi.GetCustomAttribute<EntityRelationAttribute>() != null
            );

        foreach (PropertyInfo relationProperty in relationProperties) {
            Type relationType = relationProperty.PropertyType;
            object? relationValue = relationProperty.GetValue(entity);

            if (relationValue is null) {
                continue;
            }

            bool isCollection = relationValue is IEnumerable<IEntity>;
            bool isEntity = relationValue is IEntity;

            if (!isEntity && !isCollection) {
                throw new SystemError($"Entity relation integrity problem, relation has [Relation] attribute but is not a IEnumerable<IEntity> neither IEntity assignable relation", null);
            }

            if (isEntity) {
                IEntity relEntity = (IEntity)relationValue;

                if (relEntity.Id <= 0) {
                    throw new SystemError($"Dependencies aren't allowed to be created on main Entity creation", null);
                }

                IQueryable<IEntity> dbSet = GetDbSet(relEntity.GetType());

                IEntity dbRelEntity = dbSet.Where(
                        entity => entity.Id == relEntity.Id
                    )
                    .FirstOrDefault()
                    ?? throw new SystemError($"Couldn't find relation entity ({relEntity.GetType().Name})[{relEntity.Id}]", null);

                relationProperty.SetValue(entity, dbRelEntity);
                EntityEntry entityEntry = database.Entry(dbRelEntity);
                if (entityEntry.State == EntityState.Detached) {
                    entityEntry.State = EntityState.Unchanged;
                }
            } else {
                /// --> At this point we already know it's a collection relation.
                IEnumerable<IEntity> relCollection = (IEnumerable<IEntity>)relationValue;
                if (!relCollection.Any())
                    continue;

                IEnumerable<object> dbRelCollection = [];
                Type relEntityType = relCollection.First().GetType();
                IQueryable<IEntity> dbSet = GetDbSet(relEntityType);

                foreach (IEntity relEntity in relCollection) {

                    IEntity dbRelEntity = dbSet.Where(
                            entity => entity.Id == relEntity.Id
                        )
                        .FirstOrDefault()
                        ?? throw new SystemError($"Couldn't find relation entity ({relEntity.GetType().Name})[{relEntity.Id}]", null); ;

                    EntityEntry relEntityEntry = database.Entry(dbRelEntity);
                    if (relEntityEntry.State == EntityState.Detached) {
                        relEntityEntry.State = EntityState.Unchanged;
                    }

                    dbRelCollection = dbRelCollection.Append(dbRelEntity);
                }

                object castedCollection = typeof(Enumerable)
                    .GetMethod("Cast")?
                    .MakeGenericMethod(relEntityType)
                    .Invoke(null,
                        [
                            dbRelCollection
                        ]
                    )
                    ?? throw new SystemError($"Unable to cast IEntity to Entity type object", null);

                castedCollection = typeof(Enumerable)
                    .GetMethod("ToList")?
                    .MakeGenericMethod(relEntityType)
                    .Invoke(
                        null,
                        [
                            castedCollection
                        ]
                    )
                    ?? throw new SystemError("Unable to convert entity collection", null);

                relationProperty.SetValue(entity, castedCollection);
            }
        }
        return entity;
    }

    /// <summary>
    ///     Creates a testing database context instance by activation.
    /// </summary>
    /// <typeparam name="TDatabase">
    ///     Database context type to create.
    /// </typeparam>
    /// <param name="sign">
    ///     Database signature.
    /// </param>
    /// <param name="options">
    ///     Database context EF Native options.
    /// </param>
    /// <returns>
    ///     An activated database context instance for testing purposes.
    /// </returns>
    public static TDatabase ActivateTestingDatabase<TDatabase>(string sign = "", DbContextOptions? options = null)
        where TDatabase : DatabaseBase<TDatabase>, new() {

        if (string.IsNullOrWhiteSpace(sign)) {
            TDatabase refInst = new();
            sign = refInst.Sign;
        }

        string connVar = string.Format(Q_CONNTION_TMPLATE, sign);

        string connPath = Environment.GetEnvironmentVariable(connVar)
            ?? throw new Exception($"Unable to run tests for {typeof(TDatabase).FullName}, due to couldn't be found Connection file path (Make sure the environment variable [{connVar}] is set or configured at the .runsettings tests context)");

        using FileStream fileReader = new(connPath, FileMode.Open, FileAccess.Read);

        ConnectionOptions connection = JsonSerializer.Deserialize<ConnectionOptions>(fileReader)
            ?? throw new Exception($"File ({connPath}) doesn't contain the correct format for (ConnectionOptions)");

        TDatabase? Database;
        if (options == null) {
            Database = (TDatabase?)Activator.CreateInstance(typeof(TDatabase), connection);
        } else {
            Database = (TDatabase?)Activator.CreateInstance(typeof(TDatabase), connection, options);
        }

        return Database ?? throw new Exception($"Unable to create ({typeof(TDatabase).FullName}) instance with the ConnectionOptions[{connPath}]"); ;
    }
}
